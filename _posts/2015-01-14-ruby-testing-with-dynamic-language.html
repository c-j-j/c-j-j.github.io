---
layout: post
title: 'Ruby: Testing with a dynamic language'
date: '2015-01-14T09:51:00.002-08:00'
author: Chris Jordan
tags: 
modified_time: '2015-01-14T09:51:14.641-08:00'
blogger_id: tag:blogger.com,1999:blog-7991013704143924726.post-371065243702573732
blogger_orig_url: http://chrisjordan8l.blogspot.com/2015/01/ruby-testing-with-dynamic-language.html
---

During this post, I want to pick out some differences I've found (and am enjoying) when it comes to unit testing with a dynamic language such as ruby.&nbsp;<div><br /></div><div>Today I was writing a unit test in ruby to put elements into a simple data structure, and ensuring I can extract the element after. With a statically typed language such as Java, this is where you want to think about what type the method will take, i.e. whether you want it to be a generic type or maybe you'll be creating a new interface that the method will take, etc. Then you will want to create an object in your unit test that conforms to this type and will inject this into the method.</div><div><br /></div><div>I was pleasantly surprised at how none of this was required today, it doesn't matter what particular type I want to work with during my test. The method takes any object and will stash it away for later retrieval, no methods are invoked on the injected object. I ended up using a String for this, even though later on a more complex object will be stored in this data object. The end result is far simpler code in both the unit test and production code.</div><div><br /></div><div>When it comes to invoking methods on the injected object, this is where I was initially thinking, "Now I need my Java interfaces, how can I ensure whoever uses this method will inject in the right type". When it comes to ruby, there are no warnings when injecting an object that is missing the method that'll be invoked. It expects you to do the honourable thing and thoroughly test your code and makes you as a developer responsible putting in the correct object.&nbsp;</div><div><br /></div><div>This is a nice change for me. Previously, I've worked with Java methods that may take in some interface which have several methods defined, even though only one or two of them are only being used once injected in. In my unit test, I would either have to mock this interface, or create an anonymous inner class where there is a dummy implementation for each method in that interface. Although better design may get around this mess, it does still highlight one of the many ways why ruby is easier to work with in places.</div><div><br /></div><div><br /></div>